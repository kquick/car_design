--Historically: X has always been true
-- As soon as X is false once, Y will be false forever
-- (falling edge)
node H(X:bool) returns (Y:bool);
let
    Y = X -> (X and (pre Y));
tel

--Y since inclusive X
--  Y is enabler/reset: while Y, from X true onwards
-- or
--  at X, Y until false, then reset
node SI(X,Y: bool) returns (Z:bool);
let
Z = Y and (X or (false -> pre Z));
tel

--Y since X
-- X is true, then Y until false
node S(X,Y: bool) returns (Z:bool);
let
Z = X or (Y and (false -> pre Z));
tel

--Once
--  the first time X is true, Y is true forever
--  (rising edge)
node O(X:bool) returns (Y:bool);
let
 Y = X or (false -> pre Y);
tel

--Timed Once: less than or equal to N
--  True every X and for N ticks afterward
node OTlore( N: int; X: bool) returns (Y: bool);
    var C:int;
let
    C = if X then 0
        else (-1 -> pre C + (if pre C <0 then 0 else 1));

    Y = 0 <= C and C <= N;
tel

--Timed Once: general case
-- True R ticks after each X first true until L ticks after X is last true
node OT( L: int;  R: int; X: bool) returns (Y: bool);
var  D:bool;
let
  D=delay(X, R);
  Y=OTlore(L-R, D);
tel

-- Timed Historically: general case
-- True if X has been true, and for R ticks afterwards, false thereafter
-- Always true for at least R ticks of the timeline, even if X is never true
-- L is ignored
node HT( L: int;  R: int; X: bool) returns (Y: bool);
let
  Y = not OT(L, R, not X);
tel

-- Timed Since: general case
-- R ticks after X is true, for L ticks if/while Y remains true
node ST( L: int;  R: int; X: bool; Y: bool)  returns (Z: bool);
let
  Z = S(X, Y) and OT(L, R, X);
tel

-- Timed Since Inclusive: general case
-- R ticks after X is true, for L ticks if X or while Y remains true
node SIT( L: int;  R: int; X: bool; Y: bool) returns (Z: bool);
let
  Z = SI(X, Y) and OT(L, R, X);
tel

-- Pre for integers, with an initial value at FTP
node preInt(InitialValue, X: int) returns (Y:int);
let
  Y = InitialValue -> pre X;
tel

-- Pre for reals, with an initial value at FTP
node preReal(InitialValue, X: real) returns (Y:real);
let
  Y = InitialValue -> pre X;
tel

-- Pre for booleans, with an initial value at FTP
node preBool(InitialValue, X: bool) returns (Y:bool);
let
  Y = InitialValue -> pre X;
tel

-- The equivalent of LTL's Y in Lustre.
--   Initially false, then the previous value of X (false, delay X by one)
node YtoPre(X: bool) returns (Y:bool);
let
  Y = false -> pre X;
tel

-- The equivalent of LTL's Z in Lustre.
--   Initially true, then the previous value of X (true, delay X by one)
node ZtoPre(X: bool) returns (Y:bool);
let
  Y = true -> pre X;
tel

-- Absolute value for reals
function absReal(x:real) returns(y: real);
let
  y = if (x >= 0.0) then x else -x;
tel

-- Absolute value for integers
function absInt(x:int) returns(y: int);
let
  y = if (x >= 0) then x else -x;
tel

-- Maximum value between two reals
function maxReal (a : real; b : real)
returns (z : real);
let
  z = (if (((a) >= (b))) then (a) else (b));
tel

-- Maximum value between two integers
function maxInt (a : int; b : int)
returns (z : int);
let
  z = (if (((a) >= (b))) then (a) else (b));
tel

-- Minimum value between two integers
function minInt (a : int; b : int)
returns (z : int);
let
  z = (if (((a) <= (b))) then (a) else (b));
tel

-- Minimum value between two reals
function minReal (a : real; b : real)
returns (z : real);
let
  z = (if (((a) <= (b))) then (a) else (b));
tel

node delay(X:bool;  R:int) returns(Y:bool);
var X1, X2, X3, X4, X5, X6, X7, X8, X9, X10 : bool;
let
  Y = if (R=0) then X
      else (if (R=1) then X1
      else (if (R=2) then X2
      else (if (R=3) then X3
      else (if (R=4) then X4
      else (if (R=5) then X5
      else (if (R=6) then X6
      else (if (R=7) then X7
      else (if (R=8) then X8
      else (if (R=9) then X9
      else (if (R=10) then X10
      else false (* n.b. only handles R <= 10 *)
      ))))))))));
  X1 = false -> pre X;
  X2 = false -> pre X1;
  X3 = false -> pre X2;
  X4 = false -> pre X3;
  X5 = false -> pre X4;
  X6 = false -> pre X5;
  X7 = false -> pre X6;
  X8 = false -> pre X7;
  X9 = false -> pre X8;
  X10 = false -> pre X9;
tel


type starter_state__T = enum { Started, Starting, Shutting_down, Off };
type alarm__T = enum { alarm_disabled, alarm_enabled, alarm_warning, alarm_alarming, alarm_halting_car, alarm_hold };

contract Car_2Spec( starter_state:starter_state__T; alarm:alarm__T; alarm_button:bool ) returns ( alarm__NXT:alarm__T );
let
  
  mode alarm__NXT_alarm_disabled ( require alarm__NXT = alarm_disabled; );
  mode alarm__NXT_alarm_enabled ( require alarm__NXT = alarm_enabled; );
  mode alarm__NXT_alarm_warning ( require alarm__NXT = alarm_warning; );
  mode alarm__NXT_alarm_alarming ( require alarm__NXT = alarm_alarming; );
  mode alarm__NXT_alarm_halting_car ( require alarm__NXT = alarm_halting_car; );
  mode alarm__NXT_alarm_hold ( require alarm__NXT = alarm_hold; );

  

  (* Req: upon ((alarm = alarm_enabled) & persisted(2, alarm_button)) the Car shall immediately satisfy (alarm__NXT = alarm_disabled). *)
  var ALRM_4 : bool = H(((((alarm = alarm_enabled) and (HT(2, 0, alarm_button) and HT((2 - 1), 0, (not ZtoPre(false))))) and ZtoPre((not ((alarm = alarm_enabled) and (HT(2, 0, alarm_button) and HT((2 - 1), 0, (not ZtoPre(false)))))))) => (alarm__NXT = alarm_disabled)));

  (* Req: upon ((alarm = alarm_disabled) & (alarm_button & (starter_state = Off))) the Car shall immediately satisfy (alarm__NXT = alarm_enabled). *)
  var ALRM_1 : bool = H(((((alarm = alarm_disabled) and (alarm_button and (starter_state = Off))) and ZtoPre((not ((alarm = alarm_disabled) and (alarm_button and (starter_state = Off)))))) => (alarm__NXT = alarm_enabled)));


  guarantee "ALRM-4" ALRM_4;
  guarantee "ALRM-1" ALRM_1;

tel

node Car_2 ( starter_state:starter_state__T; alarm:alarm__T; alarm_button:bool ) returns ( alarm__NXT:alarm__T );
(*@contract
   import Car_2Spec(starter_state, alarm, alarm_button) returns (alarm__NXT);
*)
let
  --%MAIN;
  
tel

