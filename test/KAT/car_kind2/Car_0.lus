--Historically: X has always been true
-- As soon as X is false once, Y will be false forever
-- (falling edge)
node H(X:bool) returns (Y:bool);
let
    Y = X -> (X and (pre Y));
tel

--Y since inclusive X
--  Y is enabler/reset: while Y, from X true onwards
-- or
--  at X, Y until false, then reset
node SI(X,Y: bool) returns (Z:bool);
let
Z = Y and (X or (false -> pre Z));
tel

--Y since X
-- X is true, then Y until false
node S(X,Y: bool) returns (Z:bool);
let
Z = X or (Y and (false -> pre Z));
tel

--Once
--  the first time X is true, Y is true forever
--  (rising edge)
node O(X:bool) returns (Y:bool);
let
 Y = X or (false -> pre Y);
tel

--Timed Once: less than or equal to N
--  True every X and for N ticks afterward
node OTlore( N: int; X: bool) returns (Y: bool);
    var C:int;
let
    C = if X then 0
        else (-1 -> pre C + (if pre C <0 then 0 else 1));

    Y = 0 <= C and C <= N;
tel

--Timed Once: general case
-- True R ticks after each X first true until L ticks after X is last true
node OT( L: int;  R: int; X: bool) returns (Y: bool);
var  D:bool;
let
  D=delay(X, R);
  Y=OTlore(L-R, D);
tel

-- Timed Historically: general case
-- True if X has been true, and for R ticks afterwards, false thereafter
-- Always true for at least R ticks of the timeline, even if X is never true
-- L is ignored
node HT( L: int;  R: int; X: bool) returns (Y: bool);
let
  Y = not OT(L, R, not X);
tel

-- Timed Since: general case
-- R ticks after X is true, for L ticks if/while Y remains true
node ST( L: int;  R: int; X: bool; Y: bool)  returns (Z: bool);
let
  Z = S(X, Y) and OT(L, R, X);
tel

-- Timed Since Inclusive: general case
-- R ticks after X is true, for L ticks if X or while Y remains true
node SIT( L: int;  R: int; X: bool; Y: bool) returns (Z: bool);
let
  Z = SI(X, Y) and OT(L, R, X);
tel

-- Pre for integers, with an initial value at FTP
node preInt(InitialValue, X: int) returns (Y:int);
let
  Y = InitialValue -> pre X;
tel

-- Pre for reals, with an initial value at FTP
node preReal(InitialValue, X: real) returns (Y:real);
let
  Y = InitialValue -> pre X;
tel

-- Pre for booleans, with an initial value at FTP
node preBool(InitialValue, X: bool) returns (Y:bool);
let
  Y = InitialValue -> pre X;
tel

-- The equivalent of LTL's Y in Lustre.
--   Initially false, then the previous value of X (false, delay X by one)
node YtoPre(X: bool) returns (Y:bool);
let
  Y = false -> pre X;
tel

-- The equivalent of LTL's Z in Lustre.
--   Initially true, then the previous value of X (true, delay X by one)
node ZtoPre(X: bool) returns (Y:bool);
let
  Y = true -> pre X;
tel

-- Absolute value for reals
function absReal(x:real) returns(y: real);
let
  y = if (x >= 0.0) then x else -x;
tel

-- Absolute value for integers
function absInt(x:int) returns(y: int);
let
  y = if (x >= 0) then x else -x;
tel

-- Maximum value between two reals
function maxReal (a : real; b : real)
returns (z : real);
let
  z = (if (((a) >= (b))) then (a) else (b));
tel

-- Maximum value between two integers
function maxInt (a : int; b : int)
returns (z : int);
let
  z = (if (((a) >= (b))) then (a) else (b));
tel

-- Minimum value between two integers
function minInt (a : int; b : int)
returns (z : int);
let
  z = (if (((a) <= (b))) then (a) else (b));
tel

-- Minimum value between two reals
function minReal (a : real; b : real)
returns (z : real);
let
  z = (if (((a) <= (b))) then (a) else (b));
tel

node delay(X:bool;  R:int) returns(Y:bool);
var X1, X2, X3, X4, X5, X6, X7, X8, X9, X10 : bool;
let
  Y = if (R=0) then X
      else (if (R=1) then X1
      else (if (R=2) then X2
      else (if (R=3) then X3
      else (if (R=4) then X4
      else (if (R=5) then X5
      else (if (R=6) then X6
      else (if (R=7) then X7
      else (if (R=8) then X8
      else (if (R=9) then X9
      else (if (R=10) then X10
      else false (* n.b. only handles R <= 10 *)
      ))))))))));
  X1 = false -> pre X;
  X2 = false -> pre X1;
  X3 = false -> pre X2;
  X4 = false -> pre X3;
  X5 = false -> pre X4;
  X6 = false -> pre X5;
  X7 = false -> pre X6;
  X8 = false -> pre X7;
  X9 = false -> pre X8;
  X10 = false -> pre X9;
tel


type starter_state__T = enum { Started, Starting, Shutting_down, Off };
type alarm__T = enum { alarm_disabled, alarm_enabled, alarm_warning, alarm_alarming, alarm_halting_car, alarm_hold };

contract Car_0Spec( start_button:bool; starter_state:starter_state__T; speed:int ) returns ( starter_state__NXT:starter_state__T );
let
  
  mode starter_state__NXT_Started ( require starter_state__NXT = Started; );
  mode starter_state__NXT_Starting ( require starter_state__NXT = Starting; );
  mode starter_state__NXT_Shutting_down ( require starter_state__NXT = Shutting_down; );
  mode starter_state__NXT_Off ( require starter_state__NXT = Off; );

  

  (* Req: upon ((! (starter_state = Off)) & ((speed = 0) & persisted(2, start_button))) the Car shall immediately satisfy (starter_state__NXT = Off). *)
  var Shutdown : bool = H(((((not (starter_state = Off)) and ((speed = 0) and (HT(2, 0, start_button) and HT((2 - 1), 0, (not ZtoPre(false)))))) and ZtoPre((not ((not (starter_state = Off)) and ((speed = 0) and (HT(2, 0, start_button) and HT((2 - 1), 0, (not ZtoPre(false))))))))) => (starter_state__NXT = Off)));

  (* Req: upon (start_button & (starter_state = Off)) the Car shall immediately satisfy (starter_state__NXT = Starting). *)
  var Start : bool = H((((start_button and (starter_state = Off)) and ZtoPre((not (start_button and (starter_state = Off))))) => (starter_state__NXT = Starting)));


  guarantee "Shutdown" Shutdown;
  guarantee "Start" Start;

tel

node Car_0 ( start_button:bool; starter_state:starter_state__T; speed:int ) returns ( starter_state__NXT:starter_state__T );
(*@contract
   import Car_0Spec(start_button, starter_state, speed) returns (starter_state__NXT);
*)
let
  --%MAIN;
  
tel

